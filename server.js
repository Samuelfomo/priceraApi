const express = require('express');
const cors = require('cors');
const app = express();
const host = '192.168.100.103';
// const host = '127.0.0.1';
const port = 3000;
const path = require('path');
const paths = require('./config/paths');

// Import de la classe Database
const Database = require(path.join(paths.MDL_DIR, 'Database'));

// Import des mod√®les
const LexiconModel = require(path.join(paths.MDL_DIR, 'LexiconModel'));
const CountryModel = require(path.join(paths.MDL_DIR, 'CountryModel'));
const ProfilModel = require(path.join(paths.MDL_DIR, 'ProfilModel'));
const FormulaModel = require(path.join(paths.MDL_DIR, 'FormulaModel'));
const ProductModel = require(path.join(paths.MDL_DIR, 'ProductModel'));
const CompanyModel = require(path.join(paths.MDL_DIR, 'CompanyModel'));
const AccountModel = require(path.join(paths.MDL_DIR, 'AccountModel'));
const UserModel = require(path.join(paths.MDL_DIR, 'UserModel'));
const SubscriptionModel = require(path.join(paths.MDL_DIR, 'SubscriptionModel'));

// Middleware
app.use(cors());
app.use(express.json());

const logger = require('./src/tools/logger');

/**
 * Initialise toutes les tables de la base de donn√©es
 */
async function initializeTables() {
    try {
        console.log('üóÑÔ∏è  Starting database tables initialization...');

        // R√©cup√©rer les instances Sequelize des mod√®les
        const models = [
            LexiconModel.getModel ? LexiconModel.getModel() : LexiconModel,
            CountryModel.getModel ? CountryModel.getModel() : CountryModel,
            ProfilModel.getModel ? ProfilModel.getModel() : ProfilModel,
            FormulaModel.getModel ? FormulaModel.getModel() : FormulaModel,
            ProductModel.getModel ? ProductModel.getModel() : ProductModel,
            CompanyModel.getModel ? CompanyModel.getModel() : CompanyModel,
            AccountModel.getModel ? AccountModel.getModel() : AccountModel,
            UserModel.getModel ? UserModel.getModel() : UserModel,
            SubscriptionModel.getModel ? SubscriptionModel.getModel() : SubscriptionModel
        ].filter(model => model !== null && model !== undefined);

        // Options d'initialisation
        const initOptions = {
            force: process.env.DB_FORCE_SYNC === 'true' || false,
            alter: process.env.DB_ALTER_SYNC === 'true' || true
        };

        // Utiliser la m√©thode statique de Database pour initialiser les tables
        await Database.initializeTables(models, initOptions);

        console.log('‚úÖ Database tables initialized successfully');
        return true;

    } catch (error) {
        console.error('‚ùå Failed to initialize database tables:', error);
        throw new Error(`Database initialization failed: ${error.message}`);
    }
}

/**
 * V√©rifie que tous les mod√®les sont correctement charg√©s
 */
function validateModels() {
    const models = [
        { name: 'LexiconModel', instance: LexiconModel },
        { name: 'CountryModel', instance: CountryModel },
        { name: 'ProfilModel', instance: ProfilModel },
        { name: 'FormulaModel', instance: FormulaModel },
        { name: 'ProductModel', instance: ProductModel },
        { name: 'CompanyModel', instance: CompanyModel },
        { name: 'AccountModel', instance: AccountModel },
        { name: 'UserModel', instance: UserModel },
        { name: 'SubscriptionModel', instance: SubscriptionModel }
    ];

    for (const model of models) {
        if (!model.instance) {
            throw new Error(`${model.name} failed to load`);
        }
        if (typeof model.instance.getModel !== 'function') {
            console.warn(`‚ö†Ô∏è  ${model.name} doesn't have getModel() method`);
        }
    }

    console.log('‚úÖ All models validated successfully');
}

/**
 * Fonction principale d'initialisation
 */
async function main() {
    try {
        console.log('üöÄ Starting application initialization...');

        // 1. Valider que tous les mod√®les sont charg√©s
        validateModels();

        // 2. Initialiser les tables de la base de donn√©es
        await initializeTables();

        console.log('‚úÖ Database and models initialized successfully');
        console.log('üéØ Application ready to handle requests');

        // 3. Initialiser les routes apr√®s l'initialisation compl√®te
        await initializeRoutes();

    } catch (error) {
        console.error('‚ùå Failed to initialize application:', error);
        process.exit(1); // Arr√™ter l'application en cas d'√©chec critique
    }
}

/**
 * Initialise les routes
 */
async function initializeRoutes() {
    try {
        console.log('üìç Initializing routes...');

        // Route pour les lexicons
        const lexiconRoute = require(path.join(paths.ROUTER, 'lexicon'));
        const countryRoute = require(path.join(paths.ROUTER, 'country'));
        const companyRoute = require(path.join(paths.ROUTER, 'company'));
        const accountRoute = require(path.join(paths.ROUTER, 'account'));
        const userRoute = require(path.join(paths.ROUTER, 'user'));
        const profilRoute = require(path.join(paths.ROUTER, 'profil'));
        app.use("/lexicon", lexiconRoute);
        app.use("/country", countryRoute);
        app.use("/company", companyRoute);
        app.use("/account", accountRoute);
        app.use("/user", userRoute);
        app.use("/profil", profilRoute);

        // Ajouter d'autres routes ici...
        // const accountRoute = require(path.join(paths.ROUTER, 'account'));
        // app.use("/account", accountRoute);

        // Route de sant√© pour v√©rifier l'√©tat du serveur
        app.get('/health', (req, res) => {
            res.json({
                status: 'OK',
                timestamp: new Date().toISOString(),
                uptime: process.uptime(),
                database: 'Connected'
            });
        });

        // Route pour v√©rifier les statistiques de la base de donn√©es
        app.get('/db-stats', (req, res) => {
            try {
                // Cr√©er une instance temporaire pour acc√©der aux stats
                const tempDb = Object.create(Database.prototype);
                tempDb._init();
                const stats = tempDb.getPoolStats();

                res.json({
                    status: 'OK',
                    pool_stats: stats,
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                res.status(500).json({
                    status: 'ERROR',
                    message: 'Failed to get database stats',
                    error: error.message
                });
            }
        });

        // Route par d√©faut
        app.get('/', (req, res) => {
            res.json({
                message: 'API Server is running',
                version: '1.0.0',
                endpoints: [
                    '/health',
                    '/db-stats',
                    '/lexicon'
                ]
            });
        });

        console.log('‚úÖ Routes initialized successfully');

    } catch (error) {
        console.error('‚ùå Failed to initialize routes:', error);
        throw error;
    }
}

/**
 * Gestion gracieuse de l'arr√™t du serveur
 */
async function gracefulShutdown(signal) {
    console.log(`\nüì° Received ${signal}. Starting graceful shutdown...`);

    try {
        // Fermer toutes les connexions de base de donn√©es via les mod√®les
        const models = [
            LexiconModel, CountryModel, ProfilModel, FormulaModel,
            ProductModel, CompanyModel, AccountModel, UserModel, SubscriptionModel
        ];

        console.log('üîå Closing database connections...');

        for (const model of models) {
            if (model && typeof model.close === 'function') {
                try {
                    await model.close();
                    console.log(`‚úÖ ${model.constructor?.name || 'Model'} connection closed`);
                } catch (error) {
                    console.error(`‚ùå Error closing ${model.constructor?.name || 'Model'}:`, error);
                }
            }
        }

        // Fermer le pool de connexions principal si accessible
        try {
            const tempDb = Object.create(Database.prototype);
            tempDb._init();
            await tempDb.closePool();
        } catch (error) {
            console.error('‚ùå Error closing main database pool:', error);
        }

        console.log('‚úÖ All database connections closed');
        console.log('üëã Graceful shutdown completed');
        process.exit(0);

    } catch (error) {
        console.error('‚ùå Error during graceful shutdown:', error);
        process.exit(1);
    }
}

/**
 * Gestionnaire d'erreurs global
 */
function setupErrorHandlers() {
    // Erreurs non captur√©es
    process.on('uncaughtException', (err) => {
        console.error('üí• Uncaught Exception:', err);
        logger.logError(`Uncaught Exception: ${err.message}\n${err.stack}`);
        gracefulShutdown('UNCAUGHT_EXCEPTION');
    });

    // Promesses rejet√©es non g√©r√©es
    process.on('unhandledRejection', (reason, promise) => {
        console.error('üí• Unhandled Rejection at:', promise, 'reason:', reason);
        logger.logError(`Unhandled Rejection: ${reason}`);
        gracefulShutdown('UNHANDLED_REJECTION');
    });

    // Signaux d'arr√™t
    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => gracefulShutdown('SIGINT'));
}

/**
 * Middleware de gestion d'erreurs pour Express
 */
app.use((err, req, res, next) => {
    console.error('Express Error:', err);
    logger.logError(`Express Error: ${err.message}\n${err.stack}`);

    res.status(500).json({
        error: 'Internal Server Error',
        message: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong',
        timestamp: new Date().toISOString()
    });
});

/**
 * Middleware pour les routes non trouv√©es
 */
// app.use('*', (req, res) => {
//     res.status(404).json({
//         error: 'Not Found',
//         message: `Route ${req.originalUrl} not found`,
//         timestamp: new Date().toISOString()
//     });
// });

// Configuration des gestionnaires d'erreurs
setupErrorHandlers();

// D√©marrage de l'application
main()
    .then(() => {
        app.listen(port, host, () => {
            console.log(`üåê Server running on http://${host}:${port}`);
            console.log(`üìä Health check available at: http://${host}:${port}/health`);
            console.log(`üìà Database stats available at: http://${host}:${port}/db-stats`);
            console.log('üéâ Server ready to handle requests!');
        });
    })
    .catch((error) => {
        console.error('‚ùå Failed to start server:', error);
        process.exit(1);
    });


// const express = require('express');
// const cors = require('cors');
// const app = express();
// const host = '192.168.100.103';
// // const host = '127.0.0.1';
// const port = 3000;
// const path = require('path');
// const paths = require('./config/paths');
//
// // Import des mod√®les
// const LexiconModel = require(path.join(paths.MDL_DIR, 'LexiconModel'));
// const CountryModel = require(path.join(paths.MDL_DIR, 'CountryModel'));
// const ProfilModel = require(path.join(paths.MDL_DIR, 'ProfilModel'));
// const FormulaModel = require(path.join(paths.MDL_DIR, 'FormulaModel'));
// const ProductModel = require(path.join(paths.MDL_DIR, 'ProductModel'));
// const CompanyModel = require(path.join(paths.MDL_DIR, 'CompanyModel'));
// const AccountModel = require(path.join(paths.MDL_DIR, 'AccountModel'));
// const UserModel = require(path.join(paths.MDL_DIR, 'UserModel'));
// const SubscriptionModel = require(path.join(paths.MDL_DIR, 'SubscriptionModel'));
//
// // Middleware
// app.use(cors());
// app.use(express.json());
//
// const logger = require('./src/tools/logger');
//
// /**
//  * Initialise tous les mod√®les avec gestion d'erreur
//  */
// async function initializeModels() {
//     const models = [
//         { name: 'LexiconModel', instance: LexiconModel },
//         { name: 'CountryModel', instance: CountryModel },
//         { name: 'ProfilModel', instance: ProfilModel },
//         { name: 'FormulaModel', instance: FormulaModel },
//         { name: 'ProductModel', instance: ProductModel },
//         { name: 'CompanyModel', instance: CompanyModel },
//         { name: 'AccountModel', instance: AccountModel },
//         { name: 'UserModel', instance: UserModel },
//         { name: 'SubscriptionModel', instance: SubscriptionModel }
//     ];
//
//     for (const model of models) {
//         try {
//             console.log(`Initializing ${model.name}...`);
//             await model.instance.initialize();
//             console.log(`‚úÖ ${model.name} initialized successfully`);
//         } catch (error) {
//             console.error(`‚ùå Failed to initialize ${model.name}:`, error);
//             throw new Error(`Model initialization failed for ${model.name}: ${error.message}`);
//         }
//     }
// }
//
// /**
//  * Fonction principale d'initialisation
//  */
// async function main() {
//     try {
//         console.log('üöÄ Starting application initialization...');
//
//         // Initialiser tous les mod√®les
//         await initializeModels();
//
//         console.log('‚úÖ All models initialized successfully');
//         console.log('üéØ Application ready to handle requests');
//
//         // Initialiser les routes apr√®s l'initialisation des mod√®les
//         await initializeRoutes();
//
//     } catch (error) {
//         console.error('‚ùå Failed to initialize application:', error);
//         process.exit(1); // Arr√™ter l'application en cas d'√©chec critique
//     }
// }
//
// /**
//  * Initialise les routes
//  */
// async function initializeRoutes() {
//     try {
//         console.log('üìç Initializing routes...');
//
//         // Route pour les lexicons
//         const lexiconRoute = require(path.join(paths.ROUTER, 'lexicon'));
//         app.use("/lexicon", lexiconRoute);
//
//         // Ajouter d'autres routes ici...
//         // const accountRoute = require(path.join(paths.ROUTER, 'account'));
//         // app.use("/account", accountRoute);
//
//         // Route de sant√© pour v√©rifier l'√©tat du serveur
//         app.get('/health', (req, res) => {
//             res.json({
//                 status: 'OK',
//                 timestamp: new Date().toISOString(),
//                 uptime: process.uptime()
//             });
//         });
//
//         // Route par d√©faut
//         app.get('/', (req, res) => {
//             res.json({
//                 message: 'API Server is running',
//                 version: '1.0.0',
//                 endpoints: [
//                     '/health',
//                     '/lexicon'
//                 ]
//             });
//         });
//
//         console.log('‚úÖ Routes initialized successfully');
//
//     } catch (error) {
//         console.error('‚ùå Failed to initialize routes:', error);
//         throw error;
//     }
// }
//
// /**
//  * Gestion gracieuse de l'arr√™t du serveur
//  */
// async function gracefulShutdown(signal) {
//     console.log(`\nüì° Received ${signal}. Starting graceful shutdown...`);
//
//     try {
//         // Fermer toutes les connexions de base de donn√©es
//         const models = [
//             LexiconModel, CountryModel, ProfilModel, FormulaModel,
//             ProductModel, CompanyModel, AccountModel, UserModel, SubscriptionModel
//         ];
//
//         for (const model of models) {
//             if (model && typeof model.close === 'function') {
//                 await model.close();
//             }
//         }
//
//         console.log('‚úÖ All database connections closed');
//         console.log('üëã Graceful shutdown completed');
//         process.exit(0);
//
//     } catch (error) {
//         console.error('‚ùå Error during graceful shutdown:', error);
//         process.exit(1);
//     }
// }
//
// /**
//  * Gestionnaire d'erreurs global
//  */
// function setupErrorHandlers() {
//     // Erreurs non captur√©es
//     process.on('uncaughtException', (err) => {
//         console.error('üí• Uncaught Exception:', err);
//         logger.logError(`Uncaught Exception: ${err.message}\n${err.stack}`);
//         process.exit(1);
//     });
//
//     // Promesses rejet√©es non g√©r√©es
//     process.on('unhandledRejection', (reason, promise) => {
//         console.error('üí• Unhandled Rejection at:', promise, 'reason:', reason);
//         logger.logError(`Unhandled Rejection: ${reason}`);
//         process.exit(1);
//     });
//
//     // Signaux d'arr√™t
//     process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
//     process.on('SIGINT', () => gracefulShutdown('SIGINT'));
// }
//
// /**
//  * Middleware de gestion d'erreurs pour Express
//  */
// app.use((err, req, res, next) => {
//     console.error('Express Error:', err);
//     logger.logError(`Express Error: ${err.message}\n${err.stack}`);
//
//     res.status(500).json({
//         error: 'Internal Server Error',
//         message: process.env.NODE_ENV === 'development' ? err.message : 'Something went wrong'
//     });
// });
//
// // /**
// //  * Middleware pour les routes non trouv√©es
// //  */
// // app.use('*', (req, res) => {
// //     res.status(404).json({
// //         error: 'Not Found',
// //         message: `Route ${req.originalUrl} not found`
// //     });
// // });
//
// // Configuration des gestionnaires d'erreurs
// setupErrorHandlers();
//
// // D√©marrage de l'application
// main()
//     .then(() => {
//         app.listen(port, host, () => {
//             console.log(`üåê Server running on http://${host}:${port}`);
//             console.log(`üìä Health check available at: http://${host}:${port}/health`);
//             console.log('üéâ Server ready to handle requests!');
//         });
//     })
//     .catch((error) => {
//         console.error('‚ùå Failed to start server:', error);
//         process.exit(1);
//     });